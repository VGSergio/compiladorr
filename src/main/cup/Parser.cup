package com.vgs.compilador;

import com.vgs.compilador.manager.ErrorManager;
import com.vgs.compilador.symbols.SymbolMain;
import com.vgs.compilador.symbols.aux.SymbolArrayIndexes;
import com.vgs.compilador.symbols.instruction.SymbolInstruction;
import com.vgs.compilador.symbols.instruction.SymbolInstructions;
import com.vgs.compilador.symbols.instruction.initialization.SymbolArrayInitialization;
import com.vgs.compilador.symbols.instruction.initialization.SymbolVariableInitialization;
import com.vgs.compilador.symbols.value.SymbolLiteral;
import com.vgs.compilador.symbols.type.SymbolType;
import com.vgs.compilador.symbols.type.SymbolTypeArray;
import com.vgs.compilador.symbols.value.SymbolValue;
import com.vgs.compilador.symbols.value.access.SymbolAccess;
import com.vgs.compilador.symbols.value.access.SymbolArrayAccess;
import com.vgs.compilador.symbols.value.access.SymbolVariableAccess;
import com.vgs.compilador.symbols.value.operation.SymbolOperation;
import com.vgs.compilador.symbols.value.operation.SymbolOperator;
import com.vgs.compilador.symbols.value.operation.SymbolOperator.Operator;
import java.util.ArrayList;
import java.util.LinkedList;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

class Parser;

parser code {:
private int line;
private int column;
private String tokenName;

@Override
public void syntax_error(Symbol cur_token) {
    getTokenData(cur_token);
    ErrorManager.syntax(line, column, tokenName, getExpectedTokens(), false);
}

@Override
public void unrecovered_syntax_error(Symbol cur_token) throws Exception {
    report_fatal_error("Couldn't repair and continue parse", cur_token);
}

@Override
public void report_fatal_error(String message, Object info) {
    done_parsing();

    getTokenData((ComplexSymbol)info);
    ErrorManager.syntax(line, column, tokenName, getExpectedTokens(), true);
}

private LinkedList<String> getExpectedTokens() {
    LinkedList<String> list = new LinkedList<>();
    for (Integer expected : expected_token_ids()) {
        list.add(symbl_name_from_id(expected));
    }
    return list;
}

private void getTokenData(Symbol cur_token){
    ComplexSymbolFactory.ComplexSymbol cs = (ComplexSymbolFactory.ComplexSymbol)cur_token;
    line = cs.getLeft().getLine();
    column = cs.getRight().getColumn();
    tokenName = cs.getName();
}
:};

// Simbolos terminales
terminal                    MAIN;
terminal                    INT, DOUBLE, BOOLEAN, CHAR, STRING, VOID;
terminal                    FINAL, NEW, RETURN;
terminal                    ASSIGN, IF, ELSE, SWITCH, CASE, BREAK, DEFAULT, FOR, WHILE;
terminal                    INPUT, PRINT;
terminal                    ADD, SUB, MUL, DIV, MOD;
terminal                    EQ, NE, GT, LT, GE, LE;
terminal                    AND, OR, NOT, XOR;
terminal                    ADD_ASSIGN, SUB_ASSIGN, MUL_ASSIGN, DIV_ASSIGN;
terminal                    LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACKET, RBRACKET, SEMICOLON, COLON, COMMA;

terminal        Integer     INTEGER_LITERAL;
terminal        Double      DOUBLE_LITERAL;
terminal        Boolean     BOOLEAN_LITERAL;
terminal        Character   CHAR_LITERAL;
terminal        String      STRING_LITERAL;
terminal        String      IDENTIFIER;

// Simbolos no terminales
nonterminal     SymbolMain                      main;
nonterminal     SymbolInstructions              instructions;
nonterminal     SymbolInstruction               instruction;
nonterminal     SymbolVariableInitialization    variableInitialization;
nonterminal     SymbolType                      variableType;
nonterminal     SymbolValue                     value, operand, literal;
nonterminal     SymbolOperation                 logicalOrOperation, logicalXorOperation, logicalAndOperation;
nonterminal     SymbolOperation                 equalityOperation, relationalOperation, unaryOperation;
nonterminal     SymbolOperation                 additiveOperation, multiplicativeOperation;
nonterminal     SymbolAccess                    access;
nonterminal     SymbolArrayInitialization       arrayInitialization;
nonterminal     SymbolTypeArray                 arrayType;
nonterminal     Integer                         arrayDims;
nonterminal     ArrayList<SymbolValue>          arrayIndexes;


// Precedendias, de menos a m√°s
// https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/Operator_precedence#tabla
precedence right    ASSIGN;         // Nivel 2 de precedencia
precedence left     OR;             // Nivel 6 de precedencia
precedence left     XOR;            // Nivel 7 de precedencia
precedence left     AND;            // Nivel 8 de precedencia
precedence left     EQ, NE;         // Nivel 9 de precedencia
precedence left     GT, LT, GE, LE; // Nivel 10 de precedencia
precedence left     ADD, SUB;       // Nivel 12 de precedencia
precedence left     MUL, DIV, MOD;  // Nivel 13 de precedencia
precedence right    NOT;            // Nivel 15 de precedencia

start with main;

main ::=
    MAIN:v1 LPAREN RPAREN LBRACKET instructions:v2 RBRACKET  {: RESULT = new SymbolMain(v2, v1xleft, v1xright); :}
;

instructions::=
    instruction:v1 instructions:v2  {: RESULT = new SymbolInstructions(v1, v2, v1xleft, v1xright); :}
|                                   {: RESULT = new SymbolInstructions(); :}
;

instruction ::=
    variableInitialization:v1 SEMICOLON     {: RESULT = v1; :}
|   arrayInitialization:v1 SEMICOLON        {: RESULT = v1; :}
|   error SEMICOLON:v1                      {: RESULT = new SymbolInstruction("Error", v1xleft, v1xright); :}
|   error RBRACKET:v1                       {: RESULT = new SymbolInstruction("Error", v1xleft, v1xright); :}
;

variableInitialization ::=
    FINAL variableType:v1 IDENTIFIER:v2 ASSIGN value:v3
        {: RESULT = new SymbolVariableInitialization(true, v1, v2, v3, v1xleft, v1xright); :}
|   variableType:v1 IDENTIFIER:v2 ASSIGN value:v3
        {: RESULT = new SymbolVariableInitialization(false, v1, v2, v3, v1xleft, v1xright); :}
|   variableType:v1 IDENTIFIER:v2
        {: RESULT = new SymbolVariableInitialization(v1, v2, v1xleft, v1xright); :}
;

variableType ::= 
    INT:v1      {: RESULT = SymbolType.INTEGER(v1xleft, v1xright); :}
|   DOUBLE:v1   {: RESULT = SymbolType.DOUBLE(v1xleft, v1xright); :}
|   BOOLEAN:v1  {: RESULT = SymbolType.BOOLEAN(v1xleft, v1xright); :}
|   CHAR:v1     {: RESULT = SymbolType.CHARACTER(v1xleft, v1xright); :}
|   STRING:v1   {: RESULT = SymbolType.STRING(v1xleft, v1xright); :}
;

value ::=
    logicalOrOperation:v1
        {: RESULT = v1; :}
;

logicalOrOperation ::=
    logicalOrOperation:v1 OR:v2 logicalXorOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.OR, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   logicalXorOperation:v1
        {: RESULT = v1; :}
;

logicalXorOperation ::=
    logicalXorOperation:v1 XOR:v2 logicalAndOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.XOR, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   logicalAndOperation:v1
        {: RESULT = v1; :}
;

logicalAndOperation ::=
    logicalAndOperation:v1 AND:v2 equalityOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.AND, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   equalityOperation:v1
        {: RESULT = v1; :}
;

equalityOperation ::=
    equalityOperation:v1 EQ:v2 relationalOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.EQ, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   equalityOperation:v1 NE:v2 relationalOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.NE, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   relationalOperation:v1
        {: RESULT = v1; :}
;

relationalOperation ::=
    relationalOperation:v1 GT:v2 additiveOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.GT, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   relationalOperation:v1 LT:v2 additiveOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.LT, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   relationalOperation:v1 GE:v2 additiveOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.GE, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   relationalOperation:v1 LE:v2 additiveOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.LE, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   additiveOperation:v1
        {: RESULT = v1; :}
;

additiveOperation ::=
    additiveOperation:v1 ADD:v2 multiplicativeOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.ADD, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   additiveOperation:v1 SUB:v2 multiplicativeOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.SUB, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   multiplicativeOperation:v1
        {: RESULT = v1; :}
;

multiplicativeOperation ::=
    multiplicativeOperation:v1 MUL:v2 unaryOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.MUL, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   multiplicativeOperation:v1 DIV:v2 unaryOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.DIV, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   multiplicativeOperation:v1 MOD:v2 unaryOperation:v3
        {: RESULT = new SymbolOperation(v1, new SymbolOperator(Operator.MOD, v2xleft, v2xright), v3, v1xleft, v1xright); :}
|   unaryOperation:v1
        {: RESULT = v1; :}
;

unaryOperation ::=
    NOT:v1 unaryOperation:v2
        {: RESULT = new SymbolOperation(v2, new SymbolOperator(Operator.NOT, v1xleft, v1xright), v1xleft, v1xright); :}
|   SUB:v1 unaryOperation:v2
        {: RESULT = new SymbolOperation(v2, new SymbolOperator(Operator.SUB, v1xleft, v1xright), v1xleft, v1xright); :}
|   operand:v1
        {: RESULT = new SymbolOperation(v1, v1xleft, v1xright); :}
;

operand ::=
    LPAREN value:v1 RPAREN
        {: RESULT = v1; :}  // Valores a calcular
|   literal:v1
        {: RESULT = v1; :}  // Valores constantes
|   access:v1
        {: RESULT = v1; :}  // Valores a buscar
;

literal ::=
    INTEGER_LITERAL:v1          {: RESULT = new SymbolLiteral(SymbolType.INTEGER(v1xleft, v1xright), v1, v1xleft, v1xright); :}
|   DOUBLE_LITERAL:v1           {: RESULT = new SymbolLiteral(SymbolType.DOUBLE(v1xleft, v1xright), v1, v1xleft, v1xright); :}
|   BOOLEAN_LITERAL:v1          {: RESULT = new SymbolLiteral(SymbolType.BOOLEAN(v1xleft, v1xright), v1, v1xleft, v1xright); :}
|   CHAR_LITERAL:v1             {: RESULT = new SymbolLiteral(SymbolType.CHARACTER(v1xleft, v1xright), v1, v1xleft, v1xright); :}
|   STRING_LITERAL:v1           {: RESULT = new SymbolLiteral(SymbolType.STRING(v1xleft, v1xright), v1, v1xleft, v1xright); :}
;

access ::=
    IDENTIFIER:v1 
        {: RESULT = new SymbolVariableAccess(v1, v1xleft, v1xright); :}
;

arrayInitialization ::=
    arrayType:v1 IDENTIFIER:v2 ASSIGN NEW variableType:v3 arrayIndexes:v4
        {: RESULT = new SymbolArrayInitialization(v1, v2, new SymbolArrayIndexes(v3, v4, v3xleft, v3xright), v1xleft, v1xright); :}
// |   arrayType:v1 IDENTIFIER:v2 ASSIGN arrayDimensions:v3 
//        {: RESULT = null; :}
;

arrayType ::=
    variableType:v1 arrayDims:v2
        {: RESULT = new SymbolTypeArray(v1, v2, v1xleft, v1xright); :}
;

arrayDims ::=
    arrayDims:v1 LSQUARE RSQUARE 
        {: RESULT = v1 + 1; :}
|   LSQUARE RSQUARE 
        {: RESULT = 1; :}
;

arrayIndexes ::=
    arrayIndexes:v1 LSQUARE value:v2 RSQUARE 
        {: v1.add(v2); RESULT = v1; :}
|   LSQUARE value:v1 RSQUARE 
        {: ArrayList<SymbolValue> lengths = new ArrayList<>(); lengths.add(v1); RESULT = lengths; :}
;